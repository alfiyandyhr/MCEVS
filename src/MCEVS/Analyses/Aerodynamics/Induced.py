import numpy as np
import openmdao.api as om
from MCEVS.Wrappers.OpenAeroStruct import VLMAeroSolverGroup
from MCEVS.Analyses.Aerodynamics.Standard import CL_Calculation, Drag_Calculation


class WingedAeroDragViaParabolicDragPolar(om.ExplicitComponent):
    """
    Computes the drag of a winged configuration in flight (cruise, climb, descent).
    CD = CD0 + K * CL**2
    Parameters:
            rho_air					: air density [kg/m**3]
    Inputs:
            Aero|Cd0				: minimum Cd of the polar drag (coefficient of parasitic drag)
            Aero|lift				: aerodynamic lift [N]
            Wing|area 				: wing area [m**2]
            Wing|aspect_ratio		: wing aspect ratio
            Aero|speed 				: air speed [m/s]
    Outputs:
            Aero|total_drag 		: aerodynamic drag [N]
            Aero|CL 				: aerodynamic coefficient of lift
            Aero|CD 				: aerodynamic coefficient of drag
            Aero|f_total 			: total equivalent flat plate area [m**2]
    Notes:
            > Based on a simple parabolic drag polar equations
            > Oswald efficiency is in the function of wing aspect ratio (typically ~0.8)
            > The wing should be un-swept.
    Source:
            Raymer, D. P. Aircraft Design: A Conceptual Approach. Reston, Virginia: American Institute of Aeronautics and Astronautics, Inc., 2006.
    """
    def initialize(self):
        self.options.declare('rho_air', types=float, desc='Air density')

    def setup(self):
        self.add_input('Aero|Cd0', desc='Minimum Cd of the polar drag')
        self.add_input('Aero|lift', units='N', desc='Lift generated by the wing')
        self.add_input('Aero|speed', units='m/s', desc='Air speed')
        self.add_input('Wing|area', units='m**2', desc='Wing reference area')
        self.add_input('Wing|aspect_ratio', desc='Wing aspect ratio')
        self.add_output('Aero|total_drag', units='N', desc='Drag of a winged configuration')
        self.add_output('Aero|CL', desc='Lift coefficient')
        self.add_output('Aero|CD', desc='Drag coefficient')
        self.add_output('Aero|f_total', units='m**2', desc='Total equivalent flat plate area')
        self.declare_partials('*', '*')

    def compute(self, inputs, outputs):
        rho_air = self.options['rho_air']
        CD0 = inputs['Aero|Cd0']
        L = inputs['Aero|lift']
        v = inputs['Aero|speed']
        S_wing = inputs['Wing|area']
        AR_wing = inputs['Wing|aspect_ratio']

        # Raymer's formula for non-swept wing (Oswald efficiency)
        wing_e = 1.78 * (1 - 0.045 * AR_wing**0.68) - 0.64

        q = 0.5 * rho_air * v**2 	 				   # dynamic pressure
        CL = L / (q * S_wing)						   # lift coefficient
        CD = CD0 + CL**2 / (np.pi * wing_e * AR_wing)  # drag coefficient
        f_total = CD * S_wing 						   # total equivalent flat plate area

        outputs['Aero|total_drag'] = q * S_wing * CD  # drag
        outputs['Aero|CL'] = CL
        outputs['Aero|CD'] = CD
        outputs['Aero|f_total'] = f_total

    def compute_partials(self, inputs, partials):
        rho_air = self.options['rho_air']
        CD0 = inputs['Aero|Cd0']
        L = inputs['Aero|lift']
        v = inputs['Aero|speed']
        S_wing = inputs['Wing|area']
        AR_wing = inputs['Wing|aspect_ratio']

        # Raymer's formula for non-swept wing (Oswald efficiency)
        wing_e = 1.78 * (1 - 0.045 * AR_wing**0.68) - 0.64

        de_dAR = - 1.78 * 0.045 * 0.68 * AR_wing**(-0.32)

        q = 0.5 * rho_air * v**2  # dynamic pressure
        CL = L / (q * S_wing)  # lift coefficient
        dq_dv = rho_air * v
        dCL_dL = 1 / (q * S_wing)
        dCL_dq = -L / (S_wing * q**2)
        dCL_dS = -L / (q * S_wing**2)

        CD = CD0 + CL**2 / (np.pi * wing_e * AR_wing)  # drag coefficient
        dCD_dCD0 = 1
        dCD_dCL = 2 * CL / (np.pi * wing_e * AR_wing)
        dCD_dL = dCD_dCL * dCL_dL
        dCD_dS = dCD_dCL * dCL_dS
        dCD_dAR = CL**2 / np.pi * (- 1 / (wing_e**2 * AR_wing) * de_dAR - 1 / (wing_e * AR_wing**2))

        dD_dq = S_wing * CD
        dD_dS = q * CD
        dD_dCD = q * S_wing

        partials['Aero|total_drag', 'Aero|Cd0'] = q * S_wing * dCD_dCD0
        partials['Aero|total_drag', 'Aero|lift'] = dD_dCD * dCD_dCL * dCL_dL
        partials['Aero|total_drag', 'Wing|area'] = dD_dS + dD_dCD * dCD_dCL * dCL_dS
        partials['Aero|total_drag', 'Wing|aspect_ratio'] = q * S_wing * CL**2 / np.pi * -(wing_e * AR_wing)**(-2) * (de_dAR * AR_wing + wing_e)
        partials['Aero|total_drag', 'Aero|speed'] = (dD_dCD * dCD_dCL * dCL_dq + dD_dq) * dq_dv
        partials['Aero|CL', 'Aero|Cd0'] = 0
        partials['Aero|CL', 'Aero|lift'] = dCL_dL
        partials['Aero|CL', 'Wing|area'] = dCL_dS
        partials['Aero|CL', 'Wing|aspect_ratio'] = 0
        partials['Aero|CL', 'Aero|speed'] = dCL_dq * dq_dv
        partials['Aero|CD', 'Aero|Cd0'] = dCD_dCD0
        partials['Aero|CD', 'Aero|lift'] = dCD_dL
        partials['Aero|CD', 'Wing|area'] = dCD_dS
        partials['Aero|CD', 'Wing|aspect_ratio'] = dCD_dAR
        partials['Aero|CD', 'Aero|speed'] = dCD_dCL * dCL_dq * dq_dv
        partials['Aero|f_total', 'Aero|Cd0'] = dCD_dCD0 * S_wing
        partials['Aero|f_total', 'Aero|lift'] = dCD_dL * S_wing
        partials['Aero|f_total', 'Wing|area'] = dCD_dS * S_wing + CD
        partials['Aero|f_total', 'Wing|aspect_ratio'] = dCD_dAR * S_wing
        partials['Aero|f_total', 'Aero|speed'] = dCD_dCL * dCL_dq * dq_dv * S_wing


class WingedAeroDragViaVLMWithTrimOAS(om.Group):
    """
    Computes the drag of a winged configuration in flight (cruise, climb, descent) using OpenAeroStruct (OAS) framework.
    CD = CD0 + CDi; where CDi is calculated using OAS, and CD0 is supplied by the user
    Parameters:
            segment_name            : segment name (e.g., cruise)
            surface_name            : surface name (e.g., wing)
            rho_air                 : air density [kg/m**3]
            CL0                     : CL at zero AoA
            num_y                   : number of panels in spanwise direction (default: 35)
            num_x                   : number of panels in chord direction (default: 11)
            AoA_guess               : initial guess of AoA [deg] (default: 5.0)
    Inputs:
            Aero|Cd0                : minimum Cd of the polar drag (coefficient of parasitic drag)
            Aero|target_lift        : target aerodynamic lift [N]
            Wing|area               : wing area [m**2]
            Wing|aspect_ratio       : wing aspect ratio
            Aero|speed              : air speed [m/s]
    Outputs:
            Aero|CL_target          : target lift coefficient
            Aero|CL_residual        : residual lift coefficient= (CL - CL_target)
            Aero|total_drag         : aerodynamic drag [N]
            Aero|CL                 : aerodynamic coefficient of lift
            Aero|CD                 : aerodynamic coefficient of drag
            Aero|f_total            : total equivalent flat plate area [m**2]
            Aero|AoA_trimmed        : trimmed AoA to achieve the target lift [deg]
    Notes:
            > Only induced drag is computed via VLM OAS; viscous and wave drag are not counted
            > Clean, rectangular, untapered, unswept wing
            > Should be used with an OpenMDAO driver !!!
    Source:
        Jasa, J. P., Hwang, J. T., and Martins, J. R. R. A., “Open-Source Coupled Aerostructural Optimization Using Python,”
        Structural and Multidisciplinary Optimization, Vol. 57, No. 4, 2018, pp. 1815–1827.
        https://doi.org/10.1007/s00158-018-1912-8
    """
    def initialize(self):
        self.options.declare('segment_name', types=str, desc='Segment name (e.g., cruise)')
        self.options.declare('surface_name', types=str, desc='Surface name (e.g., wing)')
        self.options.declare('rho_air', types=float, desc='Air density')
        self.options.declare('CL0', types=float, desc='CL at zero AoA')
        self.options.declare('num_y', types=int, default=35, desc='Number of panels in spanwise direction')
        self.options.declare('num_x', types=int, default=11, desc='Number of panels in chordwise direction')
        self.options.declare('AoA_guess', types=float, default=5.0, desc='Initial guess of AoA in deg')

    def setup(self):

        segment_name = self.options['segment_name']
        surface_name = self.options['surface_name']
        rho_air = self.options['rho_air']
        CL0 = self.options['CL0']
        num_y = self.options['num_y']
        num_x = self.options['num_x']
        AoA_guess = self.options['AoA_guess']

        self.set_input_defaults('Aero|AoA_guess', AoA_guess, units='deg')

        self.add_subsystem('target_CL_calculation',
                           CL_Calculation(rho_air=rho_air),
                           promotes_inputs=[('Aero|lift', 'Aero|target_lift'),
                                            'Aero|speed', 'Wing|area'],
                           promotes_outputs=[('Aero|CL', 'Aero|CL_target')])

        # VLM at AoA guess
        self.add_subsystem('VLMGroup_guess',
                           VLMAeroSolverGroup(segment_name='dummy_segment',
                                              surface_name='dummy_name',
                                              rho_air=rho_air,
                                              Re=0.0,
                                              Mach=0.0,
                                              CL0=CL0,
                                              CD0=0.0,
                                              with_viscous=False,
                                              with_wave=False,
                                              num_y=num_y,
                                              num_x=num_x),
                           promotes_inputs=['Wing|*', 'Aero|speed', ('Aero|AoA', 'Aero|AoA_guess')],
                           promotes_outputs=[('Aero|CL', 'Aero|CL_guess')])

        # AoA target approximation
        self.add_subsystem('AoA_target',
                           AoA_target_approximation(CL0=CL0),
                           promotes_inputs=['Aero|CL_target', 'Aero|CL_guess', 'Aero|AoA_guess'],
                           promotes_outputs=[('Aero|AoA_target', 'Aero|AoA_trimmed')])

        # VLM at AoA trimmed
        self.add_subsystem('VLMGroup_trimmed',
                           VLMAeroSolverGroup(segment_name=segment_name,
                                              surface_name=surface_name,
                                              rho_air=rho_air,
                                              Re=0.0,
                                              Mach=0.0,
                                              CL0=CL0,
                                              CD0=0.0,
                                              with_viscous=False,
                                              with_wave=False,
                                              num_y=num_y,
                                              num_x=num_x),
                           promotes_inputs=['Wing|*', 'Aero|speed', ('Aero|AoA', 'Aero|AoA_trimmed')],
                           promotes_outputs=['Aero|CL', 'Aero|CDi'])

        # Residual CL = CL - CL_target
        self.add_subsystem('CL_residual_comp',
                           om.ExecComp('CL_residual = CL - CLt', units=None),
                           promotes_inputs=[('CL', 'Aero|CL'), ('CLt', 'Aero|CL_target')],
                           promotes_outputs=[('CL_residual', 'Aero|CL_residual')])

        # Compute total CD; CD = CD0 + CDi
        self.add_subsystem('CD_comp',
                           om.ExecComp('CD = CD0 + CDi', units=None),
                           promotes_inputs=[('CD0', 'Aero|Cd0'), ('CDi', 'Aero|CDi')],
                           promotes_outputs=[('CD', 'Aero|CD')])

        # Compute total drag; D = 0.5 * rho * v**2 * S_ref * CD
        self.add_subsystem('Drag_calculation',
                           Drag_Calculation(rho_air=rho_air),
                           promotes_inputs=['Aero|CD', 'Aero|speed', 'Wing|area'],
                           promotes_outputs=[('Aero|drag', 'Aero|total_drag')])

        # Compute equivalent flat plate area
        self.add_subsystem('EFPA_comp',
                           om.ExecComp('EFPA = CD * S_ref', EFPA={'units': 'm**2'},
                                       CD={'units': None}, S_ref={'units': 'm**2'}),
                           promotes_inputs=[('CD', 'Aero|CD'), ('S_ref', 'Wing|area')],
                           promotes_outputs=[('EFPA', 'Aero|f_total')])


class AoA_target_approximation(om.ExplicitComponent):
    """
    Computes AoA target using single iteration of secant method (assuming linear region)
    AoA_target = (CL_target - CL0) / (CL_guess - CL0) * AoA_guess
    """

    def initialize(self):
        self.options.declare('CL0', types=float, desc='CL at zero AoA')

    def setup(self):
        self.add_input('Aero|CL_target', units=None, desc='Target CL')
        self.add_input('Aero|CL_guess', units=None, desc='CL at the first AoA guess')
        self.add_input('Aero|AoA_guess', units='deg', desc='The first AoA guess')
        self.add_output('Aero|AoA_target', units='deg', desc='Target AoA')
        self.declare_partials('*', '*')

    def compute(self, inputs, outputs):
        CL0 = self.options['CL0']
        CL_target = inputs['Aero|CL_target']
        CL_guess = inputs['Aero|CL_guess']
        AoA_guess = inputs['Aero|AoA_guess']

        outputs['Aero|AoA_target'] = (CL_target - CL0) / (CL_guess - CL0) * AoA_guess

    def compute_partials(self, inputs, partials):
        CL0 = self.options['CL0']
        CL_target = inputs['Aero|CL_target']
        CL_guess = inputs['Aero|CL_guess']
        AoA_guess = inputs['Aero|AoA_guess']

        partials['Aero|AoA_target', 'Aero|CL_target'] = AoA_guess / (CL_guess - CL0)
        partials['Aero|AoA_target', 'Aero|CL_guess'] = - (CL_target - CL0) / (CL_guess - CL0)**2 * AoA_guess
        partials['Aero|AoA_target', 'Aero|AoA_guess'] = (CL_target - CL0) / (CL_guess - CL0)
